# トラブルシューティング: ページ遷移時のデータ競合問題

## 発生した問題
自動テスト実行時に、入力したデータが保存されない、または消失する現象が発生しました。
具体的には、Q1〜Q8まで順番に入力していくと、最終的にまとめ画面で一部のデータ（特にQ1）が表示されないという問題でした。

## 原因分析

### 根本原因
**Next.js の動的ルート (`[id]`) におけるコンポーネント再利用とReactのライフサイクルのタイミング問題**

#### 詳細メカニズム
1.  **コンポーネントの再利用**: Next.js App Router では、同じページコンポーネント（`app/question/[id]/page.tsx`）を使用する動的ルート間（例: `/question/1` → `/question/2`）で遷移する際、デフォルトではコンポーネントインスタンスが**再利用（リサイクル）**されます。
2.  **ステートの残留**: `useState` で管理している状態（`answers`, `purpose` など）は、コンポーネントがアンマウントされない限り保持されます。つまり、Q1の入力内容が、Q2に遷移した直後も**メモリ上に残っている**状態になります。
3.  **データロードの遅延**: 遷移後、`useEffect` が実行され、新しいページ（Q2）のデータを `localStorage` から読み込んで `setAnswers` で状態を更新します。しかし、この `useEffect` の実行は**レンダリング後**です。
4.  **競合状態の発生**: 
    - 遷移直後の一瞬、画面には「Q1の入力内容」が表示されたままです（ステート残留のため）。
    - 自動テストスクリプト（Playwright）は、この「一瞬の隙」に入力操作を行います。
    - その直後に `useEffect` が走り、Q2のデータ（空または既存データ）で `setAnswers` が実行され、**テストスクリプトが入力した内容が上書きされて消えます**。

### なぜ手動操作では問題が顕在化しにくいか
人間の操作速度では、画面遷移後に「一瞬待つ」時間があり、その間に `useEffect` が完了してデータロードが終わるため、問題が表面化しにくい。
しかし、自動テストツール（Playwright）は**ミリ秒単位**で操作を行うため、この競合状態を確実に引き起こします。

## 解決策

### 実装した修正
**`key` プロパティによるコンポーネントの強制リマウント**

#### 修正内容
`app/question/[id]/page.tsx` の以下の箇所を修正しました。

**修正前:**
```typescript
<div className={styles.content}>
```

**修正後:**
```typescript
<div className={styles.content} key={categoryId}>
```

#### 修正の効果
1.  **強制的な再作成**: `key` プロパティが変更されると、Reactはその要素（とその配下のコンポーネントツリー）を**完全に破棄し、新しく作成**します。
2.  **ステートの初期化**: `useState` の状態も完全にリセットされ、初期値（`['', '', '']`）から始まります。
3.  **競合の解消**: 「前のページのデータが残っている」という状態が物理的に存在しなくなるため、競合状態が発生しません。
4.  **データロードの確実性**: 新しいコンポーネントがマウントされ、`useEffect` が走り、正しいデータがロードされてから画面が表示されます。

### 検証結果
修正後、自動テストスクリプト（`scripts/verify-app.js`）を実行した結果、以下が確認されました。
- Q1〜Q8まで全ての入力が正常に保存される
- まとめ画面で全24件の回答が正しく表示される
- データ永続化（リロード後の復元）も正常に動作する

ログ出力:
```
✅ All answers present in summary
Browser Log: SummaryPage loaded data: {answers: Array(8), ...}
```

## 教訓

### 設計段階での考慮事項
1.  **動的ルートの挙動を理解する**: Next.jsの動的ルートでは、コンポーネントが再利用される可能性があることを念頭に置く。
2.  **ライフサイクルを意識する**: `useEffect` の実行タイミング（レンダリング後）と、ユーザー操作（または自動テスト）のタイミングの関係を設計時に検討する。
3.  **`key` の活用**: 状態を完全にリセットしたい場合、`key` プロパティを使った強制リマウントは有効な手段である。

### テスト駆動開発の重要性
今回、実装後に自動テストを書いたことで問題が発覚しましたが、もし**TDD（テスト駆動開発）**を実践し、先にテストを書いていれば、この問題は実装段階で発見できた可能性があります。
`GEMINI.md` の規約に従い、次回からはテスト環境構築（Phase 0）と、各機能のテスト作成を優先します。

### WSL環境との関係
当初、「WSL環境だから動かないのでは？」という仮説を立てましたが、これは**誤り**でした。
問題の本質は、環境ではなく**コードのロジック（Reactのライフサイクル管理）**にありました。
環境のせいにする前に、コードを疑うべきでした。

## 参考情報
- React公式ドキュメント: [Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)
- Next.js App Router: [Dynamic Routes](https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes)
